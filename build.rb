=begin
Neko Engine unity build system
Version: 0.3.0.1
=end

require 'date'
require 'rbconfig'
require 'optparse'
require 'ostruct'

IncludeCFlags = "-I../Include"
LibLDFlags = "-L../bin64"

GCCDebugCFlags = "-g2 -D_DEBUG -fno-exceptions -fopenmp"
GCCReleaseCFlags = "-Ofast -fno-math-errno -fomit-frame-pointer -foptimize-strlen -fopenmp -ftree-loop-distribution -ftree-loop-distribute-patterns -funroll-loops -ffast-math -fno-exceptions -flto"

MSVCDebugCFlags = "/SUBSYSTEM:WINDOWS /DYNAMICBASE /EHsc /MACHINE:X64 /DNOMINMAX /D_CRT_SECURE_NO_WARNINGS /D_DEBUG /GS /Zi /debug"
MSVCReleaseCFlags = "/SUBSYSTEM:WINDOWS /DYNAMICBASE /EHsc /MACHINE:X64 /DNOMINMAX /D_CRT_SECURE_NO_WARNINGS /GS /GL /Gm /O2 /Od /Ox"

GCCSharedLibCFlags = "-shared -fPIC -std=c++11 -frtti"
GCCExecutableCFlags = "-std=c++11 -frtti"
MSVCSharedLibCFlags = "/DLL"
MSVCExecutableCFlags = ""

PlatformCFlags = ""

EngineLibs =
[
]

LauncherLibs =
[
	"Engine"
]

GLRendererLibs =
[
]

VKRendererLibs =
[
	"vulkan-1"
]

GameLibs =
[
	"Engine"
]

ModuleInfo = Struct.new(:file, :dirs, :type, :libs, :output)

EngineDirs = 
[
	"Engine/Audio",
	"Engine/Engine",
	"Engine/Platform",
	"Engine/PostEffects",
	"Engine/Scene",
	"Engine/System",
	"Engine/System/AssetLoader",
	"Engine/System/VFS"
]

LauncherDirs =
[
]

GLRendererDirs =
[
	"GLRenderer",
	"GLRenderer/Loaders"
]

VKRendererDirs =
[
	"VKRenderer"
]

GameDirs =
[
]

BuildList =
[
	EngineDirs,
	LauncherDirs
]

AllModules =
[
	ModuleInfo.new("engine.cpp", EngineDirs, "lib", EngineLibs, "libEngine"),
	ModuleInfo.new("launcher.cpp", LauncherDirs, "exe", LauncherLibs, "NekoLauncher"),
	ModuleInfo.new("game.cpp", GameDirs, "lib", GameLibs, "libGame"),
	ModuleInfo.new("glrenderer.cpp", GL4RendererDirs, "lib", GL4RendererLibs, "libGLRenderer"),
	ModuleInfo.new("vkrenderer.cpp", VKRendererDirs, "lib", VKRendererLibs, "libVKRenderer")
]

OutModules =
[
	AllModules[0],
	AllModules[1],
	AllModules[2]
]

BuildOptions = OpenStruct.new

def process_arguments()
	# Default options
	case platform()
	when /windows/
		BuildOptions.compilerType = "msvc"
		BuildOptions.compiler = "cl.exe"
		BuildOptions.renderers = "GLRenderer"
	else
		BuildOptions.compilerType = "gcc"
		BuildOptions.compiler = "gcc"
		BuildOptions.renderers = "GLRenderer"
	end
	
	OptionParser.new do |opt|
		opt.on('-g', '--game MODULE', 'The location of the game module source') { |o| BuildOptions.module = o }
		opt.on('-t', '--type COMPILER', 'The compiler type. Valid options = gcc, msvc. This will be used for setting the arguments') { |o| BuildOptions.compilerType = o }
		opt.on('-c', '--compiler', 'The C++ compiler path') { |o| BuildOptions.compiler = o }
		opt.on('-r', '--renderers', 'Comma separated list of the renderers to build. (GL4Renderer, GL3Renderer, VKRenderer)') { |o| BuildOptions.renderers = o }
	end.parse!
	
	BuildOptions.renderers.each_line(',') { |renderer|
		case renderer
		when /GL4Renderer/
			OutModules.push(AllModules[3])
		when /GL3Renderer/
			OutModules.push(AllModules[4])
		when /VKRenderer/
			OutModules.push(AllModules[5])
		end		 
	}
end

def create_directories()

if(!File.directory?("build"))
	Dir.mkdir "build"
end

if(!File.directory?("bin64"))
	Dir.mkdir("bin64")
end

end

def write_src_header(file)

file.write("// This file was generated by the Neko Engine Build System on " + Time.now.strftime("%d/%m/%Y at %H:%M") + "\n")
file.write("// Do not edit. All modifications will be lost.\n\n")

end

def generate_unity_file(file, dir)
	Dir.glob(dir + "/*.cpp") do |item|
		next if item == '.' or item == '..'
		file.write("#include \"../" + item + "\"\n")
	end
end

def platform()
	@platform ||= (
		host_platform = RbConfig::CONFIG['host_os']
		case host_platform
		when /mswin|msys|mingw|cygwin|bccwin|wince|emc/
			:windows
		when /darwin|mac os/
			:mac
		when /linux|solaris|bsd|qnx/
			:unix
		else
			raise "Unknown platform. You will have to modify build.rb or use CMake to build the Engine."	
		end
	)
end

def add_platform_dirs()

case platform()
	when /windows/
		EngineDirs.push("Engine/Platform/Windows")

		LauncherDirs.push("Farrah/Windows")
		
		GLRendererDirs.push("GLRenderer/Platform/Windows")

		EngineLibs.push("zlibstatic")
		EngineLibs.push("libsqlite3")
		EngineLibs.push("libpng16")
		EngineLibs.push("libvorbisfile")
		EngineLibs.push("OpenAL32")
		GLRendererLibs.push("opengl32")

		PlatformCFlags.concat("-I" + ENV['SDK'] + '/Include -L' + ENV['SDK'] + '/lib ')
	when /mac/
		EngineDirs.push("Engine/Platform/UNIX")
		EngineDirs.push("Engine/Platform/Mac")

		LauncherDirs.push("Farrah/Mac")
		
		AllModules[0][3].concat(" -framework OpenAL -framework Cocoa")
	when /unix/
		EngineDirs.push("Engine/Platform/UNIX")
		EngineDirs.push("Engine/Platform/X11")

		LauncherDirs.push("Farrah/X11")
		
		GLRendererDirs.push("GLRenderer/Platform/X11")

		PlatformCFlags.concat(" -DPLATFORM_X11")

		EngineLibs.push("openal")
		EngineLibs.push("sqlite3")
		EngineLibs.push("png")
		EngineLibs.push("vorbisfile")
		EngineLibs.push("X11")
		GLRendererLibs.push("GL")
		GLRendererLibs.push("X11")
	end
end

def generate_game_dir_list()
Dir.glob(BuildOptions.module) do |item|
	next if item == '.' or item == '..' or !File.directory?(item)
	GameDirs.push(item)
end

end

def generate_source()

OutModules.each_with_index { |outmodule, index|
	unity_file = open("build/" + outmodule.to_a[0], 'w')
	write_src_header(unity_file)
	outmodule[1].each { |dir| generate_unity_file(unity_file, dir) }
	unity_file.close
}

end

def build_module(type, libs, output, source)

case BuildOptions.compilerType
	when /gcc/
		cflags = GCCReleaseCFlags

		libs.each { |lib| cflags += " -l" + lib }

		if type == "lib"
			cflags += " " + IncludeCFlags + " " + GCCSharedLibCFlags + " " + PlatformCFlags + " " + LibLDFlags

			if system("g++ " + cflags + " -o ../bin64/" + output + ".so " + source) == 0
				raise "Compilation failed"
			end
		elsif type == "exe"
			cflags += " " + IncludeCFlags + " " + GCCExecutableCFlags + " " + PlatformCFlags + " " + LibLDFlags

			if system("g++ " + cflags + " " + " -o ../bin64/" + output + " " + source) == 0
				raise "Compilation failed"
			end
		end
	when /msvc/
		cflags = MSVCReleaseCFlags
		ldflags = ""
		libs.each { |lib| ldflags += " " + lib + ".lib" }

		if type == "lib"
			cflags += + " " + PlatformCFlags + " " + IncludeCFlags + " " + MSVCSharedLibCFlags + " " + LibLDFlags
			cflags = cflags.sub("-I", "/I")
			cflags = cflags.sub("-L", "/LIBPATH:")

			if system("cl.exe " + cflags + " " + " /OUT:../bin64/" + output + ".dll " + source) == 0
				raise "Compilation failed"
			end
		elsif type == "exe"
			cflags += " " + PlatformCFlags + " " + IncludeCFlags + " " + MSVCExecutableCFlags + " " + LibLDFlags
			cflags = cflags.sub("-I", "/I")
			cflags = cflags.sub("-L", "/LIBPATH:")

			if system("cl.exe " + cflags + " " + " /OUT:../bin64/" + output + ".exe " + source) == 0
				raise "Compilation failed"
			end
		end
end

end

puts 'Neko Engine Build System'
puts 'Version: 0.3.0.1'
puts ''
puts 'Preparing...'

process_arguments()

create_directories()

add_platform_dirs()
generate_game_dir_list()
generate_source()

Dir.chdir "build"

OutModules.each_with_index { |outmodule, index|
	puts "Building project #{index + 1} of #{OutModules.count}"
	build_module(outmodule.to_a[2], outmodule[3], outmodule.to_a[4], outmodule.to_a[0])
}

puts "Build complete."
